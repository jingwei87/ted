/// \file caont_rs.cc
/// \author Zuoru YANG (zryang@cse.cuhk.edu.hk)
/// \brief the implementation of APIs defined in AONT-RS
/// \version 0.1
/// \date 2019-03-21
///
/// \copyright Copyright (c) 2019
///

#include "caont_rs.h"


/// \brief Share encode a secret via AONT-RS
///
/// \param secretBuffer a buffer that stores the input secret
/// \param secretSize the size of the input secret
/// \param shareBuffer a buffer that stores all output shares
/// \param shareSize the size of each output share
///
/// \return true if succeed and false otherwise  
bool CaontRS::shareSecret(unsigned char *secretBuffer, int secretSize, unsigned char *shareBuffer, int *shareSize) {

    if (DEBUG_OUTPUT) {
        printf("Start to generate shares by using CAONT-RS.\n");
    }

    int alignedSecretSize, numOfSecretWords;
    int i;

    /**align the secret size into alignedSecretSize 
     * Requirement: (alignedSecretSize + keySize)
     * can be divided by (k * bytesPerSecretWord)
    */
   if (((secretSize + bytesPerSecretWord_) % (bytesPerSecretWord_ * k_)) == 0) {	
        alignedSecretSize = secretSize;		
    }
    else {
        alignedSecretSize = (bytesPerSecretWord_ * k_) * 
            (((secretSize + bytesPerSecretWord_) / (bytesPerSecretWord_ * k_)) + 1) - bytesPerSecretWord_;	
    }	
    if (alignedSecretBufferSize_ < alignedSecretSize) {

        if (DEBUG_OUTPUT) {
            printf("Error: please use an internal alignedSecretBuffer_[] of size >= %d bytes!\n",alignedSecretSize);
        }	

        return false;
    }

    /**deduce the share size into shareSize*/ 
    numOfSecretWords = alignedSecretSize / bytesPerSecretWord_;	
    (*shareSize) = bytesPerSecretWord_ * ((numOfSecretWords + 1) / k_);	


    if (DEBUG_OUTPUT) {
        printf("alignedSecretSize = %d\n", alignedSecretSize);
        printf("bytesPerSecretWord = %d\n", bytesPerSecretWord_);
        printf("numOfSecretWords = %d\n", numOfSecretWords);
    }

    /**copy the secret from secretBuffer to alignedSecretBuffer */
    memcpy(alignedSecretBuffer_, secretBuffer, secretSize);
    if (alignedSecretSize != secretSize) {

        if (DEBUG_OUTPUT) {
            printf("alignedSecretSize is larger than the size of secretSize panding remaining space with 0. \n"); 
            printf("padding remaining space: %d\n", (alignedSecretSize - secretSize));
        }

        memset(alignedSecretBuffer_ + secretSize, 0, alignedSecretSize - secretSize);
    }

    /**
     * Step 1:
     * Start to generate the CAONT package from the secret, and store it into erasureCodingData_
     * 
     * Substep 1:
     * Generate the hash h_{key}
     */

    /**generate a hash key from the original aligned secret*/
    if (!cryptoUtil_->generateHash(alignedSecretBuffer_, alignedSecretSize, key_)) {
        printf("Error: the hash calculation fails.\n");
        return false;
    }

    /**generate each of the first numOfSecretWords CAONT words with the hash key*/
    for(i = 0; i < numOfSecretWords; i++) {
        /**store the index i into wordForIndex_ */
        wordForIndex_[0] = (unsigned char) i;
        wordForIndex_[1] = (unsigned char) (i >> 8);
        wordForIndex_[2] = (unsigned char) (i >> 16);
        wordForIndex_[3] = (unsigned char) (i >> 24);

        /**Substep 1: encrypt the index i with the *hash* key, 
          * and store the cipher text in erasureCodingData_
          */
        if (!cryptoUtil_->encryptWithKey(wordForIndex_, bytesPerSecretWord_, key_, erasureCodingData_ + bytesPerSecretWord_ * i)) {
            printf("Error: the data encryption fails.\n");
            return false;
        }

        /**Substep 2: generate the CAONT word by XORing the ciphertext with the 
         * secret word
        */
        rsUtil_->addXOR(erasureCodingData_ + bytesPerSecretWord_ * i, alignedSecretBuffer_ + bytesPerSecretWord_ * i, bytesPerSecretWord_);
    }
    /**for the last AONT word, it is generated by XORing the hash with previous random key for encryption*/

    if(!cryptoUtil_->generateHash(erasureCodingData_, alignedSecretSize, erasureCodingData_ + alignedSecretSize)) {
        printf("Error: Hash generation fails! (Sharing).\n");
        
        return false;
    }

    rsUtil_->addXOR(erasureCodingData_ + alignedSecretSize, key_, bytesPerSecretWord_);

    /*directly copy the AONT package from erasureCodingData_ to shareBuffer as the first k shares*/
    memcpy(shareBuffer, erasureCodingData_, alignedSecretSize + bytesPerSecretWord_);
    
    /**Since using systematic EC, it only needs to generate only the last m shares from AONT package*/
    if(!rsUtil_->reEncoding(erasureCodingData_, shareBuffer, shareSize)) {
        printf("Error: Encoding fails.\n");
        exit(1);
    }
    return true;
}

/// \brief Reconstrct recover the original secret from AONT-RS shares
///
/// \param shareBuffer a buffer that stores the input shares
/// \param shareSize the size of each share
/// \param shareIDList a list of share IDs 
/// \param secretBuffer a buffer that stores the output secret
/// \param secretSize the size of recovered secret
///
/// \return true if succeed and false otherwise
bool CaontRS::reconstructSecret(unsigned char *shareBuffer, int shareSize, int *shareIDList, unsigned char *secretBuffer, int secretSize) {
    if (DEBUG_OUTPUT) {
        printf("Start to restore the secret by using CAONT-RS. It is same as AONT-RS\n");
    }
    AontRS::reconstructSecret(shareBuffer, shareSize, shareIDList, secretBuffer, secretSize);
    return true;
}